{"ast":null,"code":"import _classCallCheck from \"/Users/jak/repos/karen/kshack/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jak/repos/karen/kshack/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/jak/repos/karen/kshack/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/jak/repos/karen/kshack/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { RGBAFormat, RGBFormat } from '../constants.js';\nimport { ImageLoader } from './ImageLoader.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Loader } from './Loader.js';\n\nvar TextureLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(TextureLoader, _Loader);\n\n  var _super = _createSuper(TextureLoader);\n\n  function TextureLoader(manager) {\n    _classCallCheck(this, TextureLoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(TextureLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var texture = new Texture();\n      var loader = new ImageLoader(this.manager);\n      loader.setCrossOrigin(this.crossOrigin);\n      loader.setPath(this.path);\n      loader.load(url, function (image) {\n        texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\n        var isJPEG = url.search(/\\.jpe?g($|\\?)/i) > 0 || url.search(/^data\\:image\\/jpeg/) === 0;\n        texture.format = isJPEG ? RGBFormat : RGBAFormat;\n        texture.needsUpdate = true;\n\n        if (onLoad !== undefined) {\n          onLoad(texture);\n        }\n      }, onProgress, onError);\n      return texture;\n    }\n  }]);\n\n  return TextureLoader;\n}(Loader);\n\nexport { TextureLoader };","map":{"version":3,"sources":["/Users/jak/repos/karen/kshack/node_modules/three/src/loaders/TextureLoader.js"],"names":["RGBAFormat","RGBFormat","ImageLoader","Texture","Loader","TextureLoader","manager","url","onLoad","onProgress","onError","texture","loader","setCrossOrigin","crossOrigin","setPath","path","load","image","isJPEG","search","format","needsUpdate","undefined"],"mappings":";;;;AAAA,SAASA,UAAT,EAAqBC,SAArB,QAAsC,iBAAtC;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,MAAT,QAAuB,aAAvB;;IAEMC,a;;;;;AAEL,yBAAaC,OAAb,EAAuB;AAAA;;AAAA,6BAEfA,OAFe;AAItB;;;;WAED,cAAMC,GAAN,EAAWC,MAAX,EAAmBC,UAAnB,EAA+BC,OAA/B,EAAyC;AAExC,UAAMC,OAAO,GAAG,IAAIR,OAAJ,EAAhB;AAEA,UAAMS,MAAM,GAAG,IAAIV,WAAJ,CAAiB,KAAKI,OAAtB,CAAf;AACAM,MAAAA,MAAM,CAACC,cAAP,CAAuB,KAAKC,WAA5B;AACAF,MAAAA,MAAM,CAACG,OAAP,CAAgB,KAAKC,IAArB;AAEAJ,MAAAA,MAAM,CAACK,IAAP,CAAaV,GAAb,EAAkB,UAAWW,KAAX,EAAmB;AAEpCP,QAAAA,OAAO,CAACO,KAAR,GAAgBA,KAAhB,CAFoC,CAIpC;;AACA,YAAMC,MAAM,GAAGZ,GAAG,CAACa,MAAJ,CAAY,gBAAZ,IAAiC,CAAjC,IAAsCb,GAAG,CAACa,MAAJ,CAAY,oBAAZ,MAAuC,CAA5F;AAEAT,QAAAA,OAAO,CAACU,MAAR,GAAiBF,MAAM,GAAGlB,SAAH,GAAeD,UAAtC;AACAW,QAAAA,OAAO,CAACW,WAAR,GAAsB,IAAtB;;AAEA,YAAKd,MAAM,KAAKe,SAAhB,EAA4B;AAE3Bf,UAAAA,MAAM,CAAEG,OAAF,CAAN;AAEA;AAED,OAhBD,EAgBGF,UAhBH,EAgBeC,OAhBf;AAkBA,aAAOC,OAAP;AAEA;;;;EApC0BP,M;;AAyC5B,SAASC,aAAT","sourcesContent":["import { RGBAFormat, RGBFormat } from '../constants.js';\nimport { ImageLoader } from './ImageLoader.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Loader } from './Loader.js';\n\nclass TextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\tconst isJPEG = url.search( /\\.jpe?g($|\\?)/i ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n}\n\n\nexport { TextureLoader };\n"]},"metadata":{},"sourceType":"module"}