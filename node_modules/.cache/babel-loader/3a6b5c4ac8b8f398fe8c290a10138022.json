{"ast":null,"code":"export var fragmentShader = \"\\nprecision mediump float;\\n\\nvarying vec2 vUv;\\nvarying float wave;\\n\\nuniform sampler2D uTexture;\\nuniform float uTime;\\nuniform float uProg;\\nuniform float uIndex;\\n  \\nvoid main() {\\n  vec2 uv = vUv;\\n  vec2 dUv = vec2(uv.x, uv.y);\\n  vec3 texture;\\n  \\n  if (uIndex < 3.) {\\n    float w = wave;\\n    float r = texture2D(uTexture, dUv + vec2(0., 0.) + uProg * w * 0.05).r;\\n    float g = texture2D(uTexture, dUv + vec2(0., 0.) + uProg * w * 0.0).g;\\n    float b = texture2D(uTexture, dUv + vec2(0., 0.) + uProg * w * -0.02).b;\\n    texture = vec3(r, g, b);    \\n  } else if (uIndex < 6.) {\\n    float count = 10.;\\n    float smoothness = 0.5;\\n    float pr = smoothstep(-smoothness, 0., dUv.y - (1. - uProg) * (1. + smoothness));\\n    float s = 1. - step(pr, fract(count * dUv.y));\\n    texture = texture2D(uTexture, dUv * s).rgb;\\n  } else {\\n    dUv.y += wave * 0.05;\\n    float r = texture2D(uTexture, dUv + vec2(0., 0.)).r;\\n    float g = texture2D(uTexture, dUv + vec2(0., 0.)).g;\\n    float b = texture2D(uTexture, dUv + vec2(0., -0.02) * uProg).b;\\n    texture = vec3(r, g, b);\\n  }\\n  \\n  gl_FragColor = vec4(texture, 1.);\\n}\\n\";\nexport var vertexShader = \"\\nprecision mediump float;\\nvarying vec2 vUv;\\nvarying float wave;\\nuniform float uTime;\\nuniform float uProg;\\nuniform float uIndex;\\n\\n#pragma glslify: noise = require(glsl-noise/simplex/3d) \\n\\nvoid main() {\\n  vec3 pos = position;\\n\\n  if (uIndex < 3.) {      \\n    pos.z += noise(vec3(pos.x * 4. + uTime, pos.y, 0.)) * uProg;\\n    wave = pos.z;\\n    pos.z *= 3.;    \\n  } else if (uIndex < 6.) {\\n    float pr = smoothstep(0., 0.5 - sin(pos.y), uProg) * 5.;\\n    pos.z += pr;\\n  } else {\\n    pos.z += sin(pos.y * 5. + uTime) * 2. * uProg;\\n    wave = pos.z;\\n  }\\n\\n  vUv = uv;\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\\n}\\n\";","map":{"version":3,"sources":["/Users/karen/repos/karen/kshack/src/assets/shader.js"],"names":["fragmentShader","vertexShader"],"mappings":"AAAA,OAAO,IAAMA,cAAc,wnCAApB;AAwCP,OAAO,IAAMC,YAAY,wpBAAlB","sourcesContent":["export const fragmentShader = `\nprecision mediump float;\n\nvarying vec2 vUv;\nvarying float wave;\n\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform float uProg;\nuniform float uIndex;\n  \nvoid main() {\n  vec2 uv = vUv;\n  vec2 dUv = vec2(uv.x, uv.y);\n  vec3 texture;\n  \n  if (uIndex < 3.) {\n    float w = wave;\n    float r = texture2D(uTexture, dUv + vec2(0., 0.) + uProg * w * 0.05).r;\n    float g = texture2D(uTexture, dUv + vec2(0., 0.) + uProg * w * 0.0).g;\n    float b = texture2D(uTexture, dUv + vec2(0., 0.) + uProg * w * -0.02).b;\n    texture = vec3(r, g, b);    \n  } else if (uIndex < 6.) {\n    float count = 10.;\n    float smoothness = 0.5;\n    float pr = smoothstep(-smoothness, 0., dUv.y - (1. - uProg) * (1. + smoothness));\n    float s = 1. - step(pr, fract(count * dUv.y));\n    texture = texture2D(uTexture, dUv * s).rgb;\n  } else {\n    dUv.y += wave * 0.05;\n    float r = texture2D(uTexture, dUv + vec2(0., 0.)).r;\n    float g = texture2D(uTexture, dUv + vec2(0., 0.)).g;\n    float b = texture2D(uTexture, dUv + vec2(0., -0.02) * uProg).b;\n    texture = vec3(r, g, b);\n  }\n  \n  gl_FragColor = vec4(texture, 1.);\n}\n`\n\nexport const vertexShader = `\nprecision mediump float;\nvarying vec2 vUv;\nvarying float wave;\nuniform float uTime;\nuniform float uProg;\nuniform float uIndex;\n\n#pragma glslify: noise = require(glsl-noise/simplex/3d) \n\nvoid main() {\n  vec3 pos = position;\n\n  if (uIndex < 3.) {      \n    pos.z += noise(vec3(pos.x * 4. + uTime, pos.y, 0.)) * uProg;\n    wave = pos.z;\n    pos.z *= 3.;    \n  } else if (uIndex < 6.) {\n    float pr = smoothstep(0., 0.5 - sin(pos.y), uProg) * 5.;\n    pos.z += pr;\n  } else {\n    pos.z += sin(pos.y * 5. + uTime) * 2. * uProg;\n    wave = pos.z;\n  }\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}\n`   "]},"metadata":{},"sourceType":"module"}