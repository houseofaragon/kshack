{"ast":null,"code":"var _jsxFileName = \"/Users/jak/repos/karen/kshack/src/components/ArtistImage.js\",\n    _s = $RefreshSig$();\n\nimport * as THREE from 'three';\nimport { Canvas, useFrame, useLoader } from '@react-three/fiber';\nimport { useMemo, useRef } from 'react';\nimport glsl from 'glslify';\nimport { TextureLoader } from 'three/src/loaders/TextureLoader'; // import vertexShader from '../assets/vertex.glsl'\n// import fragmentShader from '../assets/fragment.glsl'\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar fragmentShader = \"\\nprecision mediump float;\\n\\nvarying vec2 vUv;\\nuniform sampler2D uTexture;\\n\\nvoid main() {\\n  vec3 texture = texture2D(uTexture, vUv).rgb;\\n  gl_FragColor = vec4(texture, 1.);\\n}\\n\";\nvar vertexShader = \"\\nprecision mediump float;\\n\\nvarying vec2 vUv;\\nuniform float uTime;\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v) {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n  \\n  // First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n  \\n  // Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n  \\n  // Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n           \\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n  \\n  // Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n  \\n  // Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\\n\\nvoid main() {\\n  vUv = uv;\\n\\n  vec3 pos = position;\\n  float noiseFreq = 3.5;\\n  float noiseAmp = 0.15; \\n  vec3 noisePos = vec3(pos.x * noiseFreq + uTime, pos.y, pos.z);\\n  pos.z += snoise(noisePos) * noiseAmp;\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\\n}\\n\";\n/*\n Load texture into shader\n https://codesandbox.io/s/divine-shape-wqf6f?from-embed=&file=/src/App.js:90-155\n*/\n\nexport function ArtistImage(_ref) {\n  _s();\n\n  var src = _ref.src,\n      index = _ref.index;\n  var imageRef = useRef();\n  var texture = useLoader(TextureLoader, src);\n  var data = useMemo(function () {\n    return {\n      uniforms: {\n        uTexture: {\n          value: texture\n        },\n        uTime: {\n          value: 0\n        },\n        uIndex: {\n          value: index\n        }\n      },\n      fragmentShader: fragmentShader,\n      vertexShader: vertexShader\n    };\n  }, []);\n  console.log(data.uniforms);\n  /* */\n\n  useFrame(function () {\n    console.log(imageRef);\n\n    if (imageRef && imageRef.current) {\n      imageRef.current.material.uniforms.uTime.value += clock.getDelta();\n    }\n  }, 1);\n  return /*#__PURE__*/_jsxDEV(\"instancedMesh\", {\n    ref: imageRef,\n    children: [/*#__PURE__*/_jsxDEV(\"planeBufferGeometry\", {\n      attach: \"geometry\",\n      args: [400, 400]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 173,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"shaderMaterial\", {\n      attach: \"material\",\n      args: [{\n        uniforms: data.uniforms,\n        vertexShader: glsl(data.vertexShader),\n        fragmentShader: glsl(data.fragmentShader)\n      }]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 174,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 172,\n    columnNumber: 5\n  }, this);\n}\n\n_s(ArtistImage, \"SClzBoH1cNnSX2Hd/XovizVWySo=\", false, function () {\n  return [useLoader, useFrame];\n});\n\n_c = ArtistImage;\n\nvar _c;\n\n$RefreshReg$(_c, \"ArtistImage\");","map":{"version":3,"sources":["/Users/jak/repos/karen/kshack/src/components/ArtistImage.js"],"names":["THREE","Canvas","useFrame","useLoader","useMemo","useRef","glsl","TextureLoader","fragmentShader","vertexShader","ArtistImage","src","index","imageRef","texture","data","uniforms","uTexture","value","uTime","uIndex","console","log","current","material","clock","getDelta"],"mappings":";;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,SAA3B,QAA4C,oBAA5C;AACA,SAASC,OAAT,EAAkBC,MAAlB,QAAgC,OAAhC;AACA,OAAOC,IAAP,MAAiB,SAAjB;AACA,SAASC,aAAT,QAA8B,iCAA9B,C,CAEA;AACA;;;AAEA,IAAMC,cAAc,4LAApB;AAYA,IAAMC,YAAY,qxGAAlB;AAwHA;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,OAAmC;AAAA;;AAAA,MAAbC,GAAa,QAAbA,GAAa;AAAA,MAARC,KAAQ,QAARA,KAAQ;AACxC,MAAMC,QAAQ,GAAGR,MAAM,EAAvB;AACA,MAAMS,OAAO,GAAGX,SAAS,CAACI,aAAD,EAAgBI,GAAhB,CAAzB;AACA,MAAMI,IAAI,GAAGX,OAAO,CAChB;AAAA,WAAO;AACHY,MAAAA,QAAQ,EAAE;AACNC,QAAAA,QAAQ,EAAE;AAAEC,UAAAA,KAAK,EAAEJ;AAAT,SADJ;AAENK,QAAAA,KAAK,EAAE;AAAED,UAAAA,KAAK,EAAE;AAAT,SAFD;AAGNE,QAAAA,MAAM,EAAE;AAAEF,UAAAA,KAAK,EAAEN;AAAT;AAHF,OADP;AAMHJ,MAAAA,cAAc,EAAdA,cANG;AAOHC,MAAAA,YAAY,EAAZA;AAPG,KAAP;AAAA,GADgB,EAUhB,EAVgB,CAApB;AAaAY,EAAAA,OAAO,CAACC,GAAR,CAAYP,IAAI,CAACC,QAAjB;AACA;;AACAd,EAAAA,QAAQ,CAAC,YAAM;AACbmB,IAAAA,OAAO,CAACC,GAAR,CAAYT,QAAZ;;AACA,QAAIA,QAAQ,IAAIA,QAAQ,CAACU,OAAzB,EAAkC;AAC9BV,MAAAA,QAAQ,CAACU,OAAT,CAAiBC,QAAjB,CAA0BR,QAA1B,CAAmCG,KAAnC,CAAyCD,KAAzC,IAAkDO,KAAK,CAACC,QAAN,EAAlD;AACD;AACJ,GALO,EAKL,CALK,CAAR;AAOF,sBACI;AAAe,IAAA,GAAG,EAAEb,QAApB;AAAA,4BACE;AAAqB,MAAA,MAAM,EAAC,UAA5B;AAAuC,MAAA,IAAI,EAAE,CAAC,GAAD,EAAM,GAAN;AAA7C;AAAA;AAAA;AAAA;AAAA,YADF,eAEE;AAAgB,MAAA,MAAM,EAAC,UAAvB;AAAkC,MAAA,IAAI,EAAE,CAAC;AACnCG,QAAAA,QAAQ,EAAED,IAAI,CAACC,QADoB;AAEnCP,QAAAA,YAAY,EAAEH,IAAI,CAACS,IAAI,CAACN,YAAN,CAFiB;AAGnCD,QAAAA,cAAc,EAAEF,IAAI,CAACS,IAAI,CAACP,cAAN;AAHe,OAAD;AAAxC;AAAA;AAAA;AAAA;AAAA,YAFF;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAWC;;GApCeE,W;UAEEP,S,EAgBhBD,Q;;;KAlBcQ,W","sourcesContent":["import * as THREE from 'three'\nimport { Canvas, useFrame, useLoader } from '@react-three/fiber'\nimport { useMemo, useRef } from 'react'\nimport glsl from 'glslify';\nimport { TextureLoader } from 'three/src/loaders/TextureLoader'\n\n// import vertexShader from '../assets/vertex.glsl'\n// import fragmentShader from '../assets/fragment.glsl'\n\nconst fragmentShader = `\nprecision mediump float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\n\nvoid main() {\n  vec3 texture = texture2D(uTexture, vUv).rgb;\n  gl_FragColor = vec4(texture, 1.);\n}\n`\n\nconst vertexShader = `\nprecision mediump float;\n\nvarying vec2 vUv;\nuniform float uTime;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  \n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n  \n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n  \n  // Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n           \n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  \n  // Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  \n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid main() {\n  vUv = uv;\n\n  vec3 pos = position;\n  float noiseFreq = 3.5;\n  float noiseAmp = 0.15; \n  vec3 noisePos = vec3(pos.x * noiseFreq + uTime, pos.y, pos.z);\n  pos.z += snoise(noisePos) * noiseAmp;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}\n`\n/*\n Load texture into shader\n https://codesandbox.io/s/divine-shape-wqf6f?from-embed=&file=/src/App.js:90-155\n*/\nexport function ArtistImage({src, index}) {\n  const imageRef = useRef()\n  const texture = useLoader(TextureLoader, src);\n  const data = useMemo(\n      () => ({\n          uniforms: {\n              uTexture: { value: texture},\n              uTime: { value: 0 },\n              uIndex: { value: index },\n          },\n          fragmentShader,\n          vertexShader\n      }),\n      []\n  )\n  \n  console.log(data.uniforms);\n  /* */\n  useFrame(() => {\n    console.log(imageRef)  \n    if (imageRef && imageRef.current) {\n        imageRef.current.material.uniforms.uTime.value += clock.getDelta();\n      }\n  }, 1)\n\nreturn (\n    <instancedMesh ref={imageRef}>\n      <planeBufferGeometry attach=\"geometry\" args={[400, 400]} />\n      <shaderMaterial attach=\"material\" args={[{\n            uniforms: data.uniforms,\n            vertexShader: glsl(data.vertexShader),\n            fragmentShader: glsl(data.fragmentShader),\n        }]} />\n      {/* <meshBasicMaterial attach=\"material\" map={texture} /> */}\n      </instancedMesh>\n)\n}\n"]},"metadata":{},"sourceType":"module"}